# Design

## Technical Walkthrough

Since Revelation is accessible as a website, we decided to go with well-known tools for frontend web development like HTML, CSS, and Bootrstrap in order to enable us to use the skills we learned in CS50 to create the markup (HTML), design/beautify it (CSS), and create some level of scalability across devices (Bootstrap). To keep with modern web design principles, we attempted to keep the same layout across all pages with an easy-to-use navigation bar to get to most other pages on the website as well as a consistent footer with the copyright on all pages, marking the end of each page. 
In terms of the backend, we used Python, specifically the Flask library, to host the website on a web server along with SQLite to store information and Jinja to connect information passed across webpages to the output of each webpage. We began the development process by first creating the layouts for all of the major webpages before incorporating the backend to actually implement functionality. In essence, we started off coding with HTML, CSS, and Bootstrap for all of the webpages before creating the database in SQLite, getting the Flask server up and running in Python, and connecting information accessed from the database to the frontend of the website through Jinja. 
There are several major functionalities for Revelation including the ability to register for a particular type of account (researcher/editor), login and access that account, search for articles, view articles, edit articles, publish articles, subscribe to the mailing list, contact Revelation, and view other users on the site. Many of these functionalities involve using Python and Jinja to either "grab" some sort of information from a SQLite table and display it for the user, whether it be related to user data or article data, or "transform" information from a form and send it to be stored in a SQLite database, whether it be related to searching, creating an account, logging in, subscribing, or contacting Revelation. 
Additionally, we used different Python libraries to run keyword extraction on articles to be displayed as labels in order to be used for categorization in the future. To accomplish this, we used the nltk library in Python primarily, specifically using TF-IDF as a way to calculate relevancy of words in each article to determine likeness to become a keyword. On a secondary note, we also used Python libraries to calculate the current date and generate a random color when publishing an article.

## Database Design

For this project, we used 1 database with 4 tables: users, articles, subscribers, and messages. The users table was designed to incorporate key information related to a user like first name, last name, username, hashed password (for security reasons), email, school, whether the user was a high school or college students (0 is high school student, 1 is undergraduate student), and whether the user was a researcher or editor (0 is researcher, 1 is editor). To keep track of users and prevent the need to transmit large amounts of information about users between tables, we also incorporated an auto-incrementing primary key called user_id. 
The articles table was developed to manage key information related to each article like the main author, secondary authors, topic (from a predefined list of 5), labels (from keyword extraction), publication date, color, assigned editor (randomly generated based on users who are editors in users table), publication status (0 is awaiting editing, 1 is published, 2 is rejected), and the contents of the article. To keep track of articles and prevent the need to transmit large amounts of information about articles between tables, we also incorporated an auto-incrementing primary key called article_id. 
Finally, the last 2 tables, subscribers and message, use an email field and email/message fields, respectively. This enables a simple data collection to be able to email everyone on the mailing list in one shot and respond to messages in a less overwhelming way.

## Access/Security Considerations

The way Revelation is designed is to be able to accomodate a wide variety of users, whether he/she be a researcher, editor, or someone who is simply browsing the page for articles and exploring. As a technical challenge, we wanted to incorporate the ability to load the same page with just a different navigation bar for both users who are logged in and users who are not logged in. This entailed having to keep track of whether a Flask session with a logged in user was active in order to send a choice between two different requests for all webpages that were accessible by both users who were logged in as well as users who were not logged in. This is reflected in the app.py file as there being 2 different requests for the same page on most pages allowing users who are logged in and users who are not logged in. This may seem repetitive but is indeed necessary to achieve the ability to show two different versions of the same page depending on the user instead of redirecting to a completely different page entirely. 
This was our biggest access consideration, so we check for the presence of a session for the pages with two types of access. However, for pages with only log-in access, we ensured that users who are not logged in that try to access the webpage get redirected to a page that is within the realm of access for a user who is not logged in. However, because even within our logged in users we have both editors and researchers, we also checked to ensure that users of a particular status (researcher/editor) were only able to access their realm of webpages with a simple SQL check to the status of a logged in user. This helped create slightly different layouts as the functionality for editors and researchers is different.
We accounted for the fact that people could edit the code to change their status upon being logged in in order to access different webpaged beyond the user's realm by ensuring much of the verification was done server-side. To ensure people were not able to submit empty forms, we checked for every single input item that was not optional to minimize reliance on users following prescribed rules.
